<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Planificateur SCR</title>
  <style>
    body { font-family: sans-serif; padding: 20px; }
    select, button { margin: 10px 0; padding: 5px; }
    li { margin-bottom: 10px; }
    .intermediate { font-style: italic; font-size: 0.9em; }
  </style>
</head>
<body>

<h2>Planificateur d'itinéraires (max 4 correspondances)</h2>

<label for="start">Départ :</label>
<select id="start"><option value="">-- Choisir --</option></select>

<label for="end">Arrivée :</label>
<select id="end"><option value="">-- Choisir --</option></select>

<button id="searchBtn">Chercher itinéraires</button>

<h3>Résultats :</h3>
<ul id="results"></ul>

<script>
// ⚠️ Mets ici ton tableau 'routes' complet
const routes = [/* ... Coller ici ton tableau de lignes ... */];

// Construire le graphe
const stopGraph = {};
routes.forEach(route => {
  const stops = route.stops;
  for (let i = 0; i < stops.length - 1; i++) {
    const from = stops[i], to = stops[i + 1];

    if (!stopGraph[from]) stopGraph[from] = [];
    stopGraph[from].push({ stop: to, route });

    // Graph orienté (on va dans le bon sens)
  }
});

// Créer la liste des arrêts uniques
const allStops = Array.from(new Set(routes.flatMap(r => r.stops))).sort();
const populateSelect = (id) => {
  const select = document.getElementById(id);
  allStops.forEach(stop => {
    const option = document.createElement("option");
    option.value = stop;
    option.textContent = stop;
    select.appendChild(option);
  });
};
populateSelect("start");
populateSelect("end");

// Recherche avec DFS jusqu'à 4 correspondances
function findPaths(from, to) {
  const maxTransfers = 4;
  const results = [];

  function dfs(currentStop, target, path, visitedStops, usedRoutes, depth) {
    if (depth > maxTransfers + 1) return;

    if (currentStop === target) {
      results.push([...path]);
      return;
    }

    const neighbors = stopGraph[currentStop] || [];
    for (const neighbor of neighbors) {
      const { stop: nextStop, route } = neighbor;
      const routeId = route.routeId;

      if (visitedStops.has(nextStop)) continue;

      const lastRoute = path.length ? path[path.length - 1].route.routeId : null;
      const routeChanged = routeId !== lastRoute;

      // Limiter les changements de route (max 4 correspondances)
      const routeChanges = usedRoutes.length + (routeChanged ? 1 : 0);
      if (routeChanges > maxTransfers + 1) continue;

      visitedStops.add(nextStop);
      path.push({ stop: nextStop, route });

      if (routeChanged) usedRoutes.push(routeId);
      dfs(nextStop, target, path, visitedStops, usedRoutes, depth + 1);
      if (routeChanged) usedRoutes.pop();

      path.pop();
      visitedStops.delete(nextStop);
    }
  }

  dfs(from, to, [{ stop: from, route: null }], new Set([from]), [], 0);
  return results;
}

// Afficher résultats
function displayResults(paths) {
  const resultsEl = document.getElementById("results");
  resultsEl.innerHTML = "";

  if (paths.length === 0) {
    resultsEl.innerHTML = "<li>Aucun itinéraire trouvé.</li>";
    return;
  }

  // Trier par longueur de trajet
  paths.sort((a, b) => a.length - b.length);

  const topPaths = paths.slice(0, 3);
  for (const path of topPaths) {
    const li = document.createElement("li");
    let html = "";

    for (let i = 0; i < path.length; i++) {
      const { stop, route } = path[i];
      const prevRoute = i > 0 ? path[i - 1].route?.routeId : null;
      const isNewRoute = route && route.routeId !== prevRoute;

      if (i === 0 || i === path.length - 1) {
        // Départ ou arrivée
        html += `<span>${stop}</span>`;
      } else {
        // Intermédiaire
        html += ` → <span class="intermediate">${stop}</span>`;
      }

      // Afficher la ligne si elle change
      if (isNewRoute) {
        html += ` <span style="color: gray">[${route.routeId}]</span>`;
      }
    }

    li.innerHTML = html;
    resultsEl.appendChild(li);
  }
}

// Événement
document.getElementById("searchBtn").addEventListener("click", () => {
  const from = document.getElementById("start").value;
  const to = document.getElementById("end").value;
  const resultsEl = document.getElementById("results");

  if (!from || !to) {
    resultsEl.innerHTML = "<li>Choisissez un départ et une arrivée.</li>";
    return;
  }
  if (from === to) {
    resultsEl.innerHTML = "<li>Départ et arrivée doivent être différents.</li>";
    return;
  }

  resultsEl.innerHTML = "<li>Recherche...</li>";
  setTimeout(() => {
    const paths = findPaths(from, to);
    displayResults(paths);
  }, 10);
});
</script>

</body>
</html>
