<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<title>Calculateur Itinéraire Stepford Express & Airlink</title>
<style>
  body { font-family: Arial, sans-serif; padding: 20px; max-width: 700px; margin: auto; }
  select, button { font-size: 1em; margin: 5px 0; }
  .operator-express { color: purple; }
  .operator-airlink { color: orange; }
  .station { margin-left: 20px; }
  .correspondance { font-weight: bold; margin-top: 10px; }
  .descente, .montee { font-weight: bold; }
</style>
</head>
<body>

<h2>Calculateur d'itinéraire Stepford Express & Airlink</h2>

<label for="start">Gare de départ :</label><br />
<select id="start"></select><br />

<label for="end">Gare d'arrivée :</label><br />
<select id="end"></select><br />

<button id="calc">Calculer l'itinéraire</button>

<pre id="result"></pre>

<script>
// Définition des lignes : chaque ligne a un nom, opérateur, stations ordonnées, temps entre gares (en minutes)
const lines = [
  {
    name: "Lyn via Benton",
    operator: "Stepford Express",
    operatorClass: "operator-express",
    stations: ["Lyn-by-the-Sea", "Northshore", "Westwyvern", "Westercoast", "Edgemead", "Leighton City", "Leighton Stepford Road", "Benton", "St Helens Bridge", "Stepford Central"],
    times: [4,3,4,3,2,4,4,3,3]
  },
  {
    name: "Newry 2",
    operator: "Stepford Express",
    operatorClass: "operator-express",
    stations: ["Stepford Central", "St Helens Bridge", "Benton", "Eden Quay", "Newry", "Newry Harbour"],
    times: [3,3,3,2,2]
  },
  {
    name: "Airlink 1",
    operator: "Airlink",
    operatorClass: "operator-airlink",
    stations: ["Stepford Central", "Airport Central"],
    times: [3]
  },
  {
    name: "Airlink 2",
    operator: "Airlink",
    operatorClass: "operator-airlink",
    stations: ["Stepford Central", "Stepford East", "Elsemere Junction", "Morganstown", "Airport Central", "Terminal 1", "Terminal 2"],
    times: [3,3,3,3,3,3]
  }
];

// Récupérer toutes les gares uniques
const allStationsSet = new Set();
lines.forEach(line => line.stations.forEach(s => allStationsSet.add(s)));
const allStations = Array.from(allStationsSet).sort();

// Remplir les menus déroulants
const startSelect = document.getElementById('start');
const endSelect = document.getElementById('end');
allStations.forEach(s => {
  let opt1 = document.createElement('option');
  opt1.value = s; opt1.textContent = s;
  startSelect.appendChild(opt1);

  let opt2 = document.createElement('option');
  opt2.value = s; opt2.textContent = s;
  endSelect.appendChild(opt2);
});

// Trouver les lignes qui contiennent une station
function getLinesForStation(station) {
  return lines.filter(line => line.stations.includes(station));
}

// Trouver segment complet entre 2 gares sur une ligne, si possible (dans les deux sens)
function getSegment(line, from, to) {
  const idxFrom = line.stations.indexOf(from);
  const idxTo = line.stations.indexOf(to);
  if (idxFrom === -1 || idxTo === -1) return null;

  const step = idxFrom < idxTo ? 1 : -1;
  let stations = [];
  for (let i = idxFrom; i !== idxTo + step; i += step) {
    stations.push(line.stations[i]);
  }
  
  // Calcul du temps total sur ce segment
  let time = 0;
  for (let i = 0; i < stations.length - 1; i++) {
    const idxA = line.stations.indexOf(stations[i]);
    if (step === 1) time += line.times[idxA];
    else time += line.times[idxA - 1];
  }
  return { stations, time, operator: line.operator, operatorClass: line.operatorClass, lineName: line.name };
}

// Recherche d'itinéraires avec max 3 correspondances, en privilégiant directs
function findRoutes(start, end, maxChanges = 3) {
  let results = [];

  // Recherche directe avant tout
  for (let line of lines) {
    let segment = getSegment(line, start, end);
    if (segment) {
      results.push({
        route: [segment],
        totalTime: segment.time,
        changes: 0
      });
      // Trajet direct trouvé, on retourne de suite
      return results;
    }
  }

  // Sinon, recherche avec correspondances par BFS limitée
  let queue = [];
  // Chaque état: { station, route: [segments], changesLeft, totalTime }
  // On commence par chaque ligne contenant start
  getLinesForStation(start).forEach(line => {
    queue.push({
      station: start,
      line,
      route: [{
        stations: [start],
        time: 0,
        operator: line.operator,
        operatorClass: line.operatorClass,
        lineName: line.name
      }],
      changesLeft: maxChanges,
      totalTime: 0
    });
  });

  let visited = new Set();

  while(queue.length > 0) {
    let state = queue.shift();
    let { station, line, route, changesLeft, totalTime } = state;
    let segment = route[route.length - 1];

    if (station === end) {
      results.push({ route, totalTime, changes: maxChanges - changesLeft });
      if(results.length >= 3) break; // on garde max 3 résultats
      continue;
    }

    // Trouver index actuelle dans la ligne
    const idxStation = line.stations.indexOf(station);

    // Avancer sur la ligne (dans les 2 directions)
    const nextIndices = [];
    if (idxStation < line.stations.length - 1) nextIndices.push(idxStation + 1);
    if (idxStation > 0) nextIndices.push(idxStation - 1);

    for (const nextIdx of nextIndices) {
      const nextStation = line.stations[nextIdx];
      const edgeId = `${station}->${nextStation}@${line.name}`;
      if (visited.has(edgeId)) continue;

      visited.add(edgeId);

      // Calcul temps segment entre station et nextStation
      let edgeTime = 0;
      if (nextIdx > idxStation) edgeTime = line.times[idxStation];
      else edgeTime = line.times[nextIdx];

      // Étendre le segment courant
      const newRoute = JSON.parse(JSON.stringify(route)); // clone profond
      newRoute[newRoute.length -1].stations.push(nextStation);
      newRoute[newRoute.length -1].time += edgeTime;

      queue.push({
        station: nextStation,
        line,
        route: newRoute,
        changesLeft,
        totalTime: totalTime + edgeTime
      });
    }

    // Changer de ligne (correspondance) possible seulement si changesLeft > 0
    if (changesLeft > 0) {
      const linesHere = getLinesForStation(station);
      for (let newLine of linesHere) {
        if (newLine.name === line.name) continue;
        const stateId = `${station}@${newLine.name}#${changesLeft-1}`;
        if (visited.has(stateId)) continue;

        visited.add(stateId);

        // Commencer un nouveau segment dans le route
        const newRoute = JSON.parse(JSON.stringify(route));
        newRoute.push({
          stations: [station],
          time: 0,
          operator: newLine.operator,
          operatorClass: newLine.operatorClass,
          lineName: newLine.name
        });

        queue.push({
          station,
          line: newLine,
          route: newRoute,
          changesLeft: changesLeft - 1,
          totalTime: totalTime
        });
      }
    }
  }

  // Trier par temps
  results.sort((a,b) => a.totalTime - b.totalTime);
  return results.slice(0, 3);
}

// Formatage de l'itinéraire pour affichage clair
function formatRoute(routeObj) {
  let output = "";
  routeObj.route.forEach((segment, idx) => {
    if(idx === 0) {
      output += `Monter à : ${segment.stations[0]} (Ligne: ${segment.lineName}, Opérateur: ${segment.operator})\n`;
    } else {
      output += `\nChanger de train à : ${segment.stations[0]} (Ligne: ${segment.lineName}, Opérateur: ${segment.operator})\n`;
      output += `Monter à : ${segment.stations[0]} (Ligne: ${segment.lineName}, Opérateur: ${segment.operator})\n`;
    }

    // Afficher stations intermédiaires en italique (tout sauf premier et dernier)
    for(let i=1; i < segment.stations.length - 1; i++) {
      output += `   → ${segment.stations[i]}\n`;
    }

    output += `Descendre à : ${segment.stations[segment.stations.length -1]}\n`;
    output += `Durée segment : ${segment.time} min\n`;
  });
  output += `\nDurée totale estimée : ${routeObj.totalTime} min\n`;
  output += `Nombre de correspondances : ${routeObj.changes}\n`;
  return output;
}

document.getElementById('calc').onclick = () => {
  const start = startSelect.value;
  const end = endSelect.value;
  if (start === end) {
    alert("Veuillez choisir deux gares différentes.");
    return;
  }
  const routes = findRoutes(start, end, 3);
  const result = document.getElementById('result');
  if (routes.length === 0) {
    result.textContent = `Aucun itinéraire trouvé entre ${start} et ${end}`;
    return;
  }
  let text = `Itinéraires de ${start} à ${end} (max 3 correspondances) :\n\n`;
  routes.forEach((r,i) => {
    text += `Option ${i+1} :\n${formatRoute(r)}\n`;
  });
  result.textContent = text;
};

</script>

</body>
</html>
