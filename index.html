<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<title>Calculateur Itinéraire Stepford Express & Airlink</title>
<style>
  body { font-family: Arial, sans-serif; padding: 20px; max-width: 700px; margin: auto; }
  select, button { font-size: 1em; margin: 5px 0; }
  .operator-express { color: purple; }
  .operator-airlink { color: orange; }
  .station { margin-left: 20px; }
  .correspondance { font-weight: bold; margin-top: 10px; }
  .descente, .montee { font-weight: bold; }
</style>
</head>
<body>

<h2>Calculateur d'itinéraire Stepford Express & Airlink</h2>

<label for="start">Gare de départ :</label><br />
<select id="start"></select><br />

<label for="end">Gare d'arrivée :</label><br />
<select id="end"></select><br />

<button id="calc">Calculer l'itinéraire</button>

<pre id="result"></pre>

<script>
// Définition des lignes : chaque ligne a un nom, opérateur, stations ordonnées, temps entre gares (en minutes)
const lines = [
  {
    name: "Lyn via Benton",
    operator: "Stepford Express",
    operatorClass: "operator-express",
    stations: ["Lyn-by-the-Sea", "Northshore", "Westwyvern", "Westercoast", "Edgemead", "Leighton City", "Leighton Stepford Road", "Benton", "St Helens Bridge", "Stepford Central"],
    times: [4,3,4,3,2,4,4,3,3]  // temps entre chaque paire de gares successives
  },
  {
    name: "Newry 2",
    operator: "Stepford Express",
    operatorClass: "operator-express",
    stations: ["Stepford Central", "St Helens Bridge", "Benton", "Eden Quay", "Newry", "Newry Harbour"],
    times: [3,3,3,2,2]
  },
  {
    name: "Airlink 1",
    operator: "Airlink",
    operatorClass: "operator-airlink",
    stations: ["Stepford Central", "Airport Central"],
    times: [3]
  },
  {
    name: "Airlink 2",
    operator: "Airlink",
    operatorClass: "operator-airlink",
    stations: ["Stepford Central", "Stepford East", "Elsemere Junction", "Morganstown", "Airport Central", "Terminal 1", "Terminal 2"],
    times: [3,3,3,3,3,3]
  }
];

// Récupérer toutes les gares uniques
const allStationsSet = new Set();
lines.forEach(line => line.stations.forEach(s => allStationsSet.add(s)));
const allStations = Array.from(allStationsSet).sort();

// Remplir les menus déroulants
const startSelect = document.getElementById('start');
const endSelect = document.getElementById('end');
allStations.forEach(s => {
  let opt1 = document.createElement('option');
  opt1.value = s; opt1.textContent = s;
  startSelect.appendChild(opt1);

  let opt2 = document.createElement('option');
  opt2.value = s; opt2.textContent = s;
  endSelect.appendChild(opt2);
});

// Trouver les lignes qui contiennent une station
function getLinesForStation(station) {
  return lines.filter(line => line.stations.includes(station));
}

// Trouver un segment de ligne entre deux stations dans l’ordre (sens aller ou retour)
function getSegment(line, from, to) {
  const idxFrom = line.stations.indexOf(from);
  const idxTo = line.stations.indexOf(to);
  if (idxFrom === -1 || idxTo === -1) return null;
  let step = idxFrom < idxTo ? 1 : -1;
  let segmentStations = [];
  for (let i = idxFrom; i !== idxTo + step; i += step) {
    segmentStations.push(line.stations[i]);
  }
  // Calcul du temps total sur ce segment
  let segmentTime = 0;
  for (let i = 0; i < segmentStations.length -1; i++) {
    let idxA = line.stations.indexOf(segmentStations[i]);
    if (step === 1) segmentTime += line.times[idxA];
    else segmentTime += line.times[idxA -1]; // pour sens inverse
  }
  return { stations: segmentStations, time: segmentTime, operator: line.operator, operatorClass: line.operatorClass, lineName: line.name };
}

// Recherche d'itinéraire avec jusqu'à 3 correspondances max
// Algorithme simple : recherche en profondeur limitée
function findRoutes(start, end, maxChanges = 3) {
  let results = [];
  let visited = new Set();

  function recurse(currentStation, currentLine, routeSoFar, timeSoFar, changesLeft) {
    if (routeSoFar.length > 100) return; // sécurité anti boucle

    if (currentStation === end) {
      results.push({ route: routeSoFar, totalTime: timeSoFar, changes: maxChanges - changesLeft });
      return;
    }

    // Si on est sur une ligne, avancer dessus
    if (currentLine) {
      const idx = currentLine.stations.indexOf(currentStation);
      // Explorer vers la prochaine station dans les 2 sens
      let nextStations = [];
      if (idx < currentLine.stations.length -1) nextStations.push(currentLine.stations[idx+1]);
      if (idx > 0) nextStations.push(currentLine.stations[idx-1]);

      for (let next of nextStations) {
        if (visited.has(currentStation + '>' + next + '|' + currentLine.name)) continue;
        visited.add(currentStation + '>' + next + '|' + currentLine.name);

        // Prolonger le segment actuel
        let lastSegment = routeSoFar[routeSoFar.length -1];
        if (lastSegment.lineName === currentLine.name) {
          // étendre la stations
          lastSegment.stations.push(next);
          // Ajouter temps entre currentStation et next
          const idxA = currentLine.stations.indexOf(currentStation);
          let t = 0;
          if (idx < currentLine.stations.indexOf(next)) t = currentLine.times[idxA];
          else t = currentLine.times[idxA -1];
          lastSegment.time += t;

          recurse(next, currentLine, routeSoFar, timeSoFar + t, changesLeft);

          // revenir en arrière (backtrack)
          lastSegment.stations.pop();
          lastSegment.time -= t;
        } else {
          // nouveau segment (normallement pas possible ici)
        }
        visited.delete(currentStation + '>' + next + '|' + currentLine.name);
      }

      // Essayer de changer de ligne (correspondance)
      if (changesLeft > 0) {
        const linesAtStation = getLinesForStation(currentStation);
        for (let line2 of linesAtStation) {
          if (line2.name === currentLine.name) continue; // même ligne, skip
          if (visited.has(currentStation + '|' + line2.name)) continue;
          visited.add(currentStation + '|' + line2.name);
          // Commencer un nouveau segment
          recurse(currentStation, line2, [...routeSoFar, { lineName: line2.name, operator: line2.operator, operatorClass: line2.operatorClass, stations: [currentStation], time: 0 }], timeSoFar, changesLeft -1);
          visited.delete(currentStation + '|' + line2.name);
        }
      }

    } else {
      // pas de ligne actuelle : on démarre sur une ligne contenant la station start
      const linesAtStation = getLinesForStation(currentStation);
      for (let line of linesAtStation) {
        if (visited.has(currentStation + '|' + line.name)) continue;
        visited.add(currentStation + '|' + line.name);
        recurse(currentStation, line, [{ lineName: line.name, operator: line.operator, operatorClass: line.operatorClass, stations: [currentStation], time: 0 }], timeSoFar, changesLeft);
        visited.delete(currentStation + '|' + line.name);
      }
    }
  }

  recurse(start, null, [], 0, maxChanges);
  // Trier par temps total asc
  results.sort((a,b) => a.totalTime - b.totalTime);
  return results.slice(0,3); // garder max 3 options
}

// Formatage sortie
function formatRoute(routeObj) {
  let output = "";
  routeObj.route.forEach((segment, i) => {
    output += `\n${i === 0 ? "Monter à" : "Changer de train à"} : ${segment.stations[0]} (Ligne: ${segment.lineName}, Opérateur: ${segment.operator})\n`;
    for (let j=1; j < segment.stations.length -1; j++) {
      output += `  → ${segment.stations[j]}\n`;
    }
    output += `Descendre à : ${segment.stations[segment.stations.length -1]}\n`;
    output += `Durée segment : ${segment.time} min\n\n`;
  });
  output += `Durée totale estimée : ${routeObj.totalTime} min\n`;
  output += `Nombre de correspondances : ${routeObj.changes}\n`;
  return output;
}

document.getElementById('calc').onclick = () => {
  const start = startSelect.value;
  const end = endSelect.value;
  if (start === end) {
    alert("Veuillez choisir deux gares différentes.");
    return;
  }
  const routes = findRoutes(start, end, 3);
  const result = document.getElementById('result');
  if (routes.length === 0) {
    result.textContent = `Aucun itinéraire trouvé entre ${start} et ${end}`;
    return;
  }
  let text = `Itinéraires de ${start} à ${end} (max 3 correspondances) :\n\n`;
  routes.forEach((r,i) => {
    text += `Option ${i+1} :\n${formatRoute(r)}\n`;
  });
  result.textContent = text;
};

</script>

</body>
</html>
